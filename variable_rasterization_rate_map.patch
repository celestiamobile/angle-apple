diff --git a/doc/ExtensionSupport.md b/doc/ExtensionSupport.md
index e0d20cea71..a7a772c07c 100644
--- a/doc/ExtensionSupport.md
+++ b/doc/ExtensionSupport.md
@@ -273,6 +273,7 @@ using data from registry_xml.py and gl.xml.
 | [GL_ANGLE_texture_external_update](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_external_update.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_texture_multisample](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_multisample.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_texture_rectangle](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_texture_rectangle.txt) |  |  |  |  |  |  |  |
+| [GL_ANGLE_variable_rasterization_rate_metal](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_variable_rasterization_rate_metal.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_vulkan_image](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_vulkan_image.txt) | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
 | [GL_ANGLE_webgl_compatibility](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_webgl_compatibility.txt) |  |  |  |  |  |  |  |
 | [GL_ANGLE_yuv_internal_format](https://chromium.googlesource.com/angle/angle/+/refs/heads/main/extensions/ANGLE_yuv_internal_format.txt) | &#x2714; |  | &#x2714; | &#x2714; | &#x2714; | &#x2714; | &#x2714; |
diff --git a/extensions/ANGLE_variable_rasterization_rate_metal.txt b/extensions/ANGLE_variable_rasterization_rate_metal.txt
new file mode 100644
index 0000000000..661d204d57
--- /dev/null
+++ b/extensions/ANGLE_variable_rasterization_rate_metal.txt
@@ -0,0 +1,95 @@
+Name
+
+    ANGLE_variable_rasterization_rate_metal
+
+Name Strings
+
+    GL_ANGLE_variable_rasterization_rate_metal
+
+Contributors
+
+    Dan Glastonbury, Apple Inc.
+
+Contact
+
+    Dan Glastonbury, Apple Inc. (djg 'at' apple 'dot' com)
+
+Status
+
+    Incomplete
+
+Version
+
+    Last Modified Date: May 5, 2023
+    Author Revision: 1
+
+Number
+
+    OpenGL ES Extension XX
+
+Dependencies
+
+Overview
+
+IP Status
+
+    No known IP claims.
+
+New Types
+
+    /*
+     * GLMTLRasterizationRateMapANGLE is an opaque handle to an id<MTLRasterizationRateMap>
+     */
+    typedef void* GLMTLRasterizationRateMapANGLE;
+
+New Procedures and Functions
+
+    void BindMetalRasterizationRateMapANGLE(GLMTLRasterizationRateMapANGLE map);
+
+New Tokens
+
+    Accepted by the <cap> parameter of Enable, Disable, and IsEnabled, by the
+    <target> parameter of Enablei, Disablei, IsEnabledi, GetBooleani_v, GetIntegeri_v, GetInteger64i_v, and by the <pname> parameter
+    of GetBooleanv, GetIntegerv, GetInteger64v, GetFloatv, 
+
+        VARIABLE_RASTERIZATION_RATE_ANGLE            0x96BC
+
+    Accepted by the <pname> parameter of GetPointerv:
+
+        METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE   0x96BD
+
+Issues
+
+    1) Specify behavior of BindMetalRaterizationRateMap(...)
+
+        - Though this extension's incomplete and being prototyped, would you
+          like to mention anything about the semantics of this new binding
+          point?
+
+        - Should this define ownership of the MTLRasterizationRateMap?
+
+        - MTLRasterizationRateMap needs to define multiple layer maps if
+          performing layered rendering - which I assume would mean using
+          multiple draw buffers in OpenGL ES semantics.
+
+        - Should this mention errors, for example that subsequent draw calls
+          will fail with INVALID_OPERATION if the number of color attachments on
+          the bound framebuffer doesn't match the number of layer maps in the
+          rasterization rate map?
+
+        - Does passing nullptr restore the GL state to its original value?
+
+        - Does binding a rasterization rate map created with a different Metal
+          device to that of ANGLE cause an error? If not, should it?
+
+    2) Specify behavior of glEnable(GL_VARIABLE_RASTERIZATION_RATE_ANGLE)
+
+        - What happens if GL_VARIABLE_RASTERIZATION_RATE_ANGLE is enabled, but
+          no rasterization rate map is bound?
+
+        In the current implementation, if the feature is enable but no map is
+        bound the GL renders as normal and no error is generated.
+
+    3) Does this feature require a GLSL extension to allow access to
+       rasterization_rate_map_decoder when rendering with an enabled map? Should
+       gl_FragCoord automatically be adjusted when rendering with a map?
diff --git a/include/GLES2/gl2ext_angle.h b/include/GLES2/gl2ext_angle.h
index 7141949b82..7f77a2515e 100644
--- a/include/GLES2/gl2ext_angle.h
+++ b/include/GLES2/gl2ext_angle.h
@@ -689,6 +689,18 @@ GL_APICALL void GL_APIENTRY glLogicOpANGLE (GLenum);
 #endif
 #endif /* GL_ANGLE_logic_op */
 
+#ifndef GL_ANGLE_variable_rasterization_rate_metal
+#define GL_ANGLE_variable_rasterization_rate_metal 1
+
+#define GL_VARIABLE_RASTERIZATION_RATE_ANGLE            0x96BC
+#define GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE   0x96BD
+typedef void *GLMTLRasterizationRateMapANGLE;
+typedef void (GL_APIENTRYP PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC) (GLMTLRasterizationRateMapANGLE);
+#ifdef GL_GLEXT_PROTOTYPES
+GL_APICALL void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLMTLRasterizationRateMapANGLE map);
+#endif
+#endif /* GL_ANGLE_variable_rasterization_rate_metal */
+
 #ifndef GL_ANGLE_program_binary_readiness_query
 #define GL_ANGLE_program_binary_readiness_query
 #define GL_PROGRAM_BINARY_READY_ANGLE    0x96BE
diff --git a/include/platform/autogen/FeaturesMtl_autogen.h b/include/platform/autogen/FeaturesMtl_autogen.h
index 3efcc4506a..0131400374 100644
--- a/include/platform/autogen/FeaturesMtl_autogen.h
+++ b/include/platform/autogen/FeaturesMtl_autogen.h
@@ -74,6 +74,12 @@ struct FeaturesMtl : FeatureSetBase
         &members,
     };
 
+    FeatureInfo hasVariableRasterizationRate = {
+        "hasVariableRasterizationRate",
+        FeatureCategory::MetalFeatures,
+        &members,
+    };
+
     FeatureInfo allowInlineConstVertexData = {
         "allowInlineConstVertexData",
         FeatureCategory::MetalFeatures,
diff --git a/include/platform/mtl_features.json b/include/platform/mtl_features.json
index 386e3a8313..d4f403aa89 100644
--- a/include/platform/mtl_features.json
+++ b/include/platform/mtl_features.json
@@ -70,6 +70,13 @@
                 "The renderer supports MTL(Shared)Event"
             ]
         },
+        {
+            "name": "has_variable_rasterization_rate",
+            "category": "Features",
+            "description": [
+                "The renderer supports variable rasterization rate"
+            ]
+        },
         {
             "name": "allow_inline_const_vertex_data",
             "category": "Features",
diff --git a/scripts/generate_entry_points.py b/scripts/generate_entry_points.py
index e5b0a90d31..06e245b937 100755
--- a/scripts/generate_entry_points.py
+++ b/scripts/generate_entry_points.py
@@ -1018,6 +1018,7 @@ FORMAT_DICT = {
     "GLint": "%d",
     "GLintptr": UNSIGNED_LONG_LONG_FORMAT,
     "GLSETBLOBPROCANGLE": POINTER_FORMAT,
+    "GLMTLRasterizationRateMapANGLE": POINTER_FORMAT,
     "GLshort": "%d",
     "GLsizei": "%d",
     "GLsizeiptr": UNSIGNED_LONG_LONG_FORMAT,
diff --git a/scripts/gl_angle_ext.xml b/scripts/gl_angle_ext.xml
index 07bbbc5d8a..e3702c97f4 100644
--- a/scripts/gl_angle_ext.xml
+++ b/scripts/gl_angle_ext.xml
@@ -13,6 +13,7 @@
     <types>
         <type>typedef GLsizeiptr (<apientry/> *<name>GLGETBLOBPROCANGLE</name>)(const void *key, GLsizeiptr keySize, void *value, GLsizeiptr valueSize, const void *userParam);</type>
         <type>typedef void (<apientry/> *<name>GLSETBLOBPROCANGLE</name>)(const void *key, GLsizeiptr keySize, const void *value, GLsizeiptr valueSize, const void *userParam);</type>
+        <type>typedef void *<name>GLMTLRasterizationRateMapANGLE</name>;</type>
     </types>
 
     <!-- SECTION: GL parameter class type definitions. -->
@@ -936,6 +937,10 @@
             <param len="1">void **<name>params</name></param>
             <alias name="glGetPointerv"/>
         </command>
+        <command>
+            <proto>void <name>glBindMetalRasterizationRateMapANGLE</name></proto>
+            <param><ptype>GLMTLRasterizationRateMapANGLE</ptype> <name>map</name></param>
+        </command>
     </commands>
 
     <!-- SECTION: ANGLE extension interface definitions -->
@@ -1326,6 +1331,13 @@
                 <command name="glGetPointervANGLE"/>
             </require>
         </extension>
+        <extension name="GL_ANGLE_variable_rasterization_rate_metal" supported="gles2">
+            <require>
+                <enum name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+                <enum name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+                <command name="glBindMetalRasterizationRateMapANGLE"/>
+            </require>
+        </extension>
     </extensions>
 
     <!-- SECTION: GL enumerant (token) definitions. -->
@@ -1509,4 +1521,9 @@
         <enum value="0x96EF" name="GL_BLOB_CACHE_SET_FUNCTION_ANGLE"/>
         <enum value="0x972D" name="GL_BLOB_CACHE_USER_PARAM_ANGLE"/>
     </enums>
+
+    <enums namespace="GL" start="0x96BC" end="0x96BD" vendor="ANGLE">
+        <enum value="0x96BC" name="GL_VARIABLE_RASTERIZATION_RATE_ANGLE"/>
+        <enum value="0x96BD" name="GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE"/>
+    </enums>
 </registry>
diff --git a/scripts/registry_xml.py b/scripts/registry_xml.py
index 32b6e274b0..9c7f724929 100644
--- a/scripts/registry_xml.py
+++ b/scripts/registry_xml.py
@@ -75,6 +75,7 @@ angle_requestable_extensions = [
     "GL_ANGLE_texture_external_update",
     "GL_ANGLE_texture_multisample",
     "GL_ANGLE_texture_rectangle",
+    "GL_ANGLE_variable_rasterization_rate_metal",
     "GL_ANGLE_vulkan_image",
     "GL_ANGLE_yuv_internal_format",
     "GL_CHROMIUM_color_buffer_float_rgb",
diff --git a/src/common/entry_points_enum_autogen.cpp b/src/common/entry_points_enum_autogen.cpp
index 2b9c5d06e3..96402add8e 100644
--- a/src/common/entry_points_enum_autogen.cpp
+++ b/src/common/entry_points_enum_autogen.cpp
@@ -534,6 +534,8 @@ const char *GetEntryPointName(EntryPoint ep)
             return "glBindFramebufferOES";
         case EntryPoint::GLBindImageTexture:
             return "glBindImageTexture";
+        case EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            return "glBindMetalRasterizationRateMapANGLE";
         case EntryPoint::GLBindProgramPipeline:
             return "glBindProgramPipeline";
         case EntryPoint::GLBindProgramPipelineEXT:
diff --git a/src/common/entry_points_enum_autogen.h b/src/common/entry_points_enum_autogen.h
index c0b468afdc..7cef827f77 100644
--- a/src/common/entry_points_enum_autogen.h
+++ b/src/common/entry_points_enum_autogen.h
@@ -273,6 +273,7 @@ enum class EntryPoint
     GLBindFramebuffer,
     GLBindFramebufferOES,
     GLBindImageTexture,
+    GLBindMetalRasterizationRateMapANGLE,
     GLBindProgramPipeline,
     GLBindProgramPipelineEXT,
     GLBindRenderbuffer,
diff --git a/src/common/frame_capture_utils_autogen.cpp b/src/common/frame_capture_utils_autogen.cpp
index 157c2a8bcd..a747c15481 100644
--- a/src/common/frame_capture_utils_autogen.cpp
+++ b/src/common/frame_capture_utils_autogen.cpp
@@ -232,6 +232,10 @@ void WriteParamCaptureReplay(std::ostream &os, const CallCapture &call, const Pa
             WriteParamValueReplay<ParamType::TGLSETBLOBPROCANGLE>(
                 os, call, param.value.GLSETBLOBPROCANGLEVal);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            WriteParamValueReplay<ParamType::TGLMTLRasterizationRateMapANGLE>(
+                os, call, param.value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case ParamType::TGLbitfield:
             WriteParamValueReplay<ParamType::TGLbitfield>(os, call, param.value.GLbitfieldVal);
             break;
@@ -1014,6 +1018,8 @@ const char *ParamTypeToString(ParamType paramType)
             return "GLGETBLOBPROCANGLE";
         case ParamType::TGLSETBLOBPROCANGLE:
             return "GLSETBLOBPROCANGLE";
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return "GLMTLRasterizationRateMapANGLE";
         case ParamType::TGLbitfield:
             return "GLbitfield";
         case ParamType::TGLboolean:
diff --git a/src/common/frame_capture_utils_autogen.h b/src/common/frame_capture_utils_autogen.h
index d52e35290c..7e3050b0df 100644
--- a/src/common/frame_capture_utils_autogen.h
+++ b/src/common/frame_capture_utils_autogen.h
@@ -103,6 +103,7 @@ enum class ParamType
     TGLDEBUGPROCKHR,
     TGLGETBLOBPROCANGLE,
     TGLSETBLOBPROCANGLE,
+    TGLMTLRasterizationRateMapANGLE,
     TGLbitfield,
     TGLboolean,
     TGLbooleanPointer,
@@ -275,7 +276,7 @@ enum class ParamType
     TvoidPointerPointer,
 };
 
-constexpr uint32_t kParamTypeCount = 238;
+constexpr uint32_t kParamTypeCount = 239;
 
 union ParamValue
 {
@@ -341,6 +342,7 @@ union ParamValue
     GLDEBUGPROCKHR GLDEBUGPROCKHRVal;
     GLGETBLOBPROCANGLE GLGETBLOBPROCANGLEVal;
     GLSETBLOBPROCANGLE GLSETBLOBPROCANGLEVal;
+    GLMTLRasterizationRateMapANGLE GLMTLRasterizationRateMapANGLEVal;
     GLbitfield GLbitfieldVal;
     GLboolean GLbooleanVal;
     GLboolean *GLbooleanPointerVal;
@@ -919,6 +921,14 @@ inline GLSETBLOBPROCANGLE GetParamVal<ParamType::TGLSETBLOBPROCANGLE, GLSETBLOBP
     return value.GLSETBLOBPROCANGLEVal;
 }
 
+template <>
+inline GLMTLRasterizationRateMapANGLE
+GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, GLMTLRasterizationRateMapANGLE>(
+    const ParamValue &value)
+{
+    return value.GLMTLRasterizationRateMapANGLEVal;
+}
+
 template <>
 inline GLbitfield GetParamVal<ParamType::TGLbitfield, GLbitfield>(const ParamValue &value)
 {
@@ -2253,6 +2263,8 @@ T AccessParamValue(ParamType paramType, const ParamValue &value)
             return GetParamVal<ParamType::TGLGETBLOBPROCANGLE, T>(value);
         case ParamType::TGLSETBLOBPROCANGLE:
             return GetParamVal<ParamType::TGLSETBLOBPROCANGLE, T>(value);
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            return GetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE, T>(value);
         case ParamType::TGLbitfield:
             return GetParamVal<ParamType::TGLbitfield, T>(value);
         case ParamType::TGLboolean:
@@ -2980,6 +2992,14 @@ inline void SetParamVal<ParamType::TGLSETBLOBPROCANGLE>(GLSETBLOBPROCANGLE value
     valueOut->GLSETBLOBPROCANGLEVal = valueIn;
 }
 
+template <>
+inline void SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(
+    GLMTLRasterizationRateMapANGLE valueIn,
+    ParamValue *valueOut)
+{
+    valueOut->GLMTLRasterizationRateMapANGLEVal = valueIn;
+}
+
 template <>
 inline void SetParamVal<ParamType::TGLbitfield>(GLbitfield valueIn, ParamValue *valueOut)
 {
@@ -4355,6 +4375,9 @@ void InitParamValue(ParamType paramType, T valueIn, ParamValue *valueOut)
         case ParamType::TGLSETBLOBPROCANGLE:
             SetParamVal<ParamType::TGLSETBLOBPROCANGLE>(valueIn, valueOut);
             break;
+        case ParamType::TGLMTLRasterizationRateMapANGLE:
+            SetParamVal<ParamType::TGLMTLRasterizationRateMapANGLE>(valueIn, valueOut);
+            break;
         case ParamType::TGLbitfield:
             SetParamVal<ParamType::TGLbitfield>(valueIn, valueOut);
             break;
diff --git a/src/common/gl_enum_utils_autogen.cpp b/src/common/gl_enum_utils_autogen.cpp
index 58bc6c4cbc..397a032cfa 100644
--- a/src/common/gl_enum_utils_autogen.cpp
+++ b/src/common/gl_enum_utils_autogen.cpp
@@ -2828,6 +2828,10 @@ const char *GLenumToString(GLESEnum enumGroup, unsigned int value)
                     return "GL_RGBX8_ANGLE";
                 case 0x96BB:
                     return "GL_SHADER_BINARY_ANGLE";
+                case 0x96BC:
+                    return "GL_VARIABLE_RASTERIZATION_RATE_ANGLE";
+                case 0x96BD:
+                    return "GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE";
                 case 0x96BE:
                     return "GL_PROGRAM_BINARY_READY_ANGLE";
                 case 0x96C0:
@@ -11819,6 +11823,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_MESH_VERTICES_OUT_NV", 0x9579},
     {"GL_MESH_WORK_GROUP_SIZE_EXT", 0x953E},
     {"GL_MESH_WORK_GROUP_SIZE_NV", 0x953E},
+    {"GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE", 0x96BD},
     {"GL_MIN", 0x8007},
     {"GL_MINMAX", 0x802E},
     {"GL_MINMAX_EXT", 0x802E},
@@ -14498,6 +14503,7 @@ static StringEnumEntry g_stringEnumTable[] = {
     {"GL_VARIABLE_E_NV", 0x8527},
     {"GL_VARIABLE_F_NV", 0x8528},
     {"GL_VARIABLE_G_NV", 0x8529},
+    {"GL_VARIABLE_RASTERIZATION_RATE_ANGLE", 0x96BC},
     {"GL_VARIANT_ARRAY_EXT", 0x87E8},
     {"GL_VARIANT_ARRAY_POINTER_EXT", 0x87E9},
     {"GL_VARIANT_ARRAY_STRIDE_EXT", 0x87E6},
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index d1dc4c68fb..d618ffdda8 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -10,6 +10,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/libANGLE/Context.cpp b/src/libANGLE/Context.cpp
index 462df8de76..bf08d0c143 100644
--- a/src/libANGLE/Context.cpp
+++ b/src/libANGLE/Context.cpp
@@ -10026,6 +10026,12 @@ void Context::onActiveTransformFeedbackChange()
     mPrivateStateCache.invalidateCachedBasicDrawElementsError();
 }
 
+void Context::bindMetalRasterizationRateMap(GLMTLRasterizationRateMapANGLE map)
+{
+    ANGLE_CONTEXT_TRY(mImplementation->bindMetalRasterizationRateMap(this, map));
+    getMutablePrivateState()->setVariableRasterizationRateMap(map);
+}
+
 // ErrorSet implementation.
 ErrorSet::ErrorSet(Debug *debug,
                    const angle::FrontendFeatures &frontendFeatures,
diff --git a/src/libANGLE/Context_gles_ext_autogen.h b/src/libANGLE/Context_gles_ext_autogen.h
index 2827237912..507d8dab97 100644
--- a/src/libANGLE/Context_gles_ext_autogen.h
+++ b/src/libANGLE/Context_gles_ext_autogen.h
@@ -623,6 +623,8 @@
     void invalidateTexture(TextureType targetPacked);                                              \
     /* GL_ANGLE_texture_multisample */                                                             \
     /* GL_ANGLE_texture_rectangle */                                                               \
+    /* GL_ANGLE_variable_rasterization_rate_metal */                                               \
+    void bindMetalRasterizationRateMap(GLMTLRasterizationRateMapANGLE map);                        \
     /* GL_ANGLE_vulkan_image */                                                                    \
     void acquireTextures(GLuint numTextures, const TextureID *texturesPacked,                      \
                          const GLenum *layouts);                                                   \
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 58bd6a68bb..c6750aa537 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -9,6 +9,8 @@
 #ifdef UNSAFE_BUFFERS_BUILD
 #    pragma allow_unsafe_buffers
 #endif
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
 
 #include "libANGLE/State.h"
 
@@ -378,6 +380,8 @@ PrivateState::PrivateState(const Version &clientVersion,
       mLogicOp(LogicalOperation::Copy),
       mPatchVertices(3),
       mPixelLocalStorageActivePlanes(0),
+      mVariableRasterizationRateEnabled(false),
+      mVariableRasterizationRateMap(nullptr),
       mNoSimultaneousConstantColorAndAlphaBlendFunc(false),
       mSetBlendIndexedInvoked(false),
       mSetBlendFactorsIndexedInvoked(false),
@@ -1443,6 +1447,26 @@ void PrivateState::setLogicOp(LogicalOperation opcode)
     }
 }
 
+void PrivateState::setVariableRasterizationRateEnabled(bool enabled)
+{
+    if (mVariableRasterizationRateEnabled != enabled)
+    {
+        mVariableRasterizationRateEnabled = enabled;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
+void PrivateState::setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map)
+{
+    if (mVariableRasterizationRateMap != map)
+    {
+        mVariableRasterizationRateMap = map;
+        mDirtyBits.set(state::DIRTY_BIT_EXTENDED);
+        mExtendedDirtyBits.set(state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+    }
+}
+
 void PrivateState::setVertexAttribf(GLuint index, const GLfloat values[4])
 {
     ASSERT(static_cast<size_t>(index) < mVertexAttribCurrentValues.size());
@@ -1575,6 +1599,9 @@ void PrivateState::setEnableFeature(GLenum feature, bool enabled)
         case GL_FETCH_PER_SAMPLE_ARM:
             setFetchPerSample(enabled);
             return;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            setVariableRasterizationRateEnabled(enabled);
+            return;
         default:
             break;
     }
@@ -1741,6 +1768,8 @@ bool PrivateState::getEnableFeature(GLenum feature) const
             return mShadingRatePreserveAspectRatio;
         case GL_FETCH_PER_SAMPLE_ARM:
             return mFetchPerSample;
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return mVariableRasterizationRateEnabled;
     }
 
     ASSERT(mClientVersion < ES_2_0);
@@ -3706,6 +3735,9 @@ void State::getPointerv(const Context *context, GLenum pname, void **params) con
         case GL_BLOB_CACHE_USER_PARAM_ANGLE:
             *params = const_cast<void *>(getBlobCacheCallbacks().userParam);
             break;
+        case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+            *params = privateState().getVariableRasterizationRateMap();
+            break;
         default:
             UNREACHABLE();
             break;
diff --git a/src/libANGLE/State.h b/src/libANGLE/State.h
index 67bc68df46..4ca5f50bea 100644
--- a/src/libANGLE/State.h
+++ b/src/libANGLE/State.h
@@ -178,6 +178,7 @@ enum ExtendedDirtyBitType
     EXTENDED_DIRTY_BIT_LOGIC_OP_ENABLED,              // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_LOGIC_OP,                      // ANGLE_logic_op
     EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT,       // KHR_blend_operation_advanced_coherent
+    EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,   // ANGLE_variable_rasterization_rate_metal
 
     EXTENDED_DIRTY_BIT_INVALID,
     EXTENDED_DIRTY_BIT_MAX = EXTENDED_DIRTY_BIT_INVALID,
@@ -490,6 +491,15 @@ class PrivateState : angle::NonCopyable
     bool hasActivelyOverriddenPLSDrawBuffers(GLint *firstActivePLSDrawBuffer) const;
     bool isActivelyOverriddenPLSDrawBuffer(GLint drawbuffer) const;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    void setVariableRasterizationRateEnabled(bool enabled);
+    bool isVariableRasterizationRateEnabled() const { return mVariableRasterizationRateEnabled; }
+    void setVariableRasterizationRateMap(GLMTLRasterizationRateMapANGLE map);
+    GLMTLRasterizationRateMapANGLE getVariableRasterizationRateMap() const
+    {
+        return mVariableRasterizationRateMap;
+    }
+
     // Line width state setter
     void setLineWidth(GLfloat width);
     float getLineWidth() const { return mLineWidth; }
@@ -781,6 +791,10 @@ class PrivateState : angle::NonCopyable
     DrawBufferMask mPLSDeferredBlendEnables;
     BlendStateExt::ColorMaskStorage::Type mPLSDeferredColorMasks;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool mVariableRasterizationRateEnabled;
+    GLMTLRasterizationRateMapANGLE mVariableRasterizationRateMap;
+
     // GLES1 emulation: state specific to GLES1
     GLES1State mGLES1State;
 
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.cpp b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
index fc412bcb17..3508303fc3 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.cpp
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.cpp
@@ -4134,6 +4134,18 @@ CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
     return CallCapture(angle::EntryPoint::GLGetTranslatedShaderSourceANGLE, std::move(paramBuffer));
 }
 
+CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                      bool isCallValid,
+                                                      GLMTLRasterizationRateMapANGLE map)
+{
+    ParamBuffer paramBuffer;
+
+    paramBuffer.addValueParam("map", ParamType::TGLMTLRasterizationRateMapANGLE, map);
+
+    return CallCapture(angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE,
+                       std::move(paramBuffer));
+}
+
 CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                         bool isCallValid,
                                         GLuint numTextures,
diff --git a/src/libANGLE/capture/capture_gles_ext_autogen.h b/src/libANGLE/capture/capture_gles_ext_autogen.h
index 8481b64c43..33f6c1fe4d 100644
--- a/src/libANGLE/capture/capture_gles_ext_autogen.h
+++ b/src/libANGLE/capture/capture_gles_ext_autogen.h
@@ -893,6 +893,11 @@ angle::CallCapture CaptureGetTranslatedShaderSourceANGLE(const State &glState,
                                                          GLsizei *length,
                                                          GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+angle::CallCapture CaptureBindMetalRasterizationRateMapANGLE(const State &glState,
+                                                             bool isCallValid,
+                                                             GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 angle::CallCapture CaptureAcquireTexturesANGLE(const State &glState,
                                                bool isCallValid,
diff --git a/src/libANGLE/gles_extensions_autogen.cpp b/src/libANGLE/gles_extensions_autogen.cpp
index e40558e729..886a8f4252 100644
--- a/src/libANGLE/gles_extensions_autogen.cpp
+++ b/src/libANGLE/gles_extensions_autogen.cpp
@@ -285,6 +285,7 @@ const ExtensionInfoMap &GetExtensionInfoMap()
         map["GL_ANGLE_texture_external_update"] = enableableExtension(&Extensions::textureExternalUpdateANGLE);
         map["GL_ANGLE_texture_multisample"] = enableableExtension(&Extensions::textureMultisampleANGLE);
         map["GL_ANGLE_texture_rectangle"] = enableableExtension(&Extensions::textureRectangleANGLE);
+        map["GL_ANGLE_variable_rasterization_rate_metal"] = enableableExtension(&Extensions::variableRasterizationRateMetalANGLE);
         map["GL_ANGLE_vulkan_image"] = enableableExtension(&Extensions::vulkanImageANGLE);
         map["GL_ANGLE_webgl_compatibility"] = esOnlyExtension(&Extensions::webglCompatibilityANGLE);
         map["GL_ANGLE_yuv_internal_format"] = enableableExtension(&Extensions::yuvInternalFormatANGLE);
diff --git a/src/libANGLE/gles_extensions_autogen.h b/src/libANGLE/gles_extensions_autogen.h
index b527f5cb15..0d831a248c 100644
--- a/src/libANGLE/gles_extensions_autogen.h
+++ b/src/libANGLE/gles_extensions_autogen.h
@@ -815,6 +815,9 @@ struct Extensions
     // GL_ANGLE_texture_rectangle
     bool textureRectangleANGLE = false;
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    bool variableRasterizationRateMetalANGLE = false;
+
     // GL_ANGLE_vulkan_image
     bool vulkanImageANGLE = false;
 
diff --git a/src/libANGLE/renderer/ContextImpl.cpp b/src/libANGLE/renderer/ContextImpl.cpp
index a50cc11b14..3e5613b2f2 100644
--- a/src/libANGLE/renderer/ContextImpl.cpp
+++ b/src/libANGLE/renderer/ContextImpl.cpp
@@ -121,4 +121,12 @@ const angle::ShadingRateMap &ContextImpl::getSupportedFragmentShadingRateEXTSamp
     static angle::ShadingRateMap empty;
     return empty;
 }
+
+angle::Result ContextImpl::bindMetalRasterizationRateMap(gl::Context *,
+                                                         GLMTLRasterizationRateMapANGLE map)
+{
+    UNREACHABLE();
+    return angle::Result::Stop;
+}
+
 }  // namespace rx
diff --git a/src/libANGLE/renderer/ContextImpl.h b/src/libANGLE/renderer/ContextImpl.h
index 5b1cf26b04..db906bb3e5 100644
--- a/src/libANGLE/renderer/ContextImpl.h
+++ b/src/libANGLE/renderer/ContextImpl.h
@@ -283,6 +283,10 @@ class ContextImpl : public GLImplFactory
     virtual const angle::PerfMonitorCounterGroupsInfo &getPerfMonitorCountersInfo() const;
     virtual const angle::PerfMonitorCounterGroups &getPerfMonitorCounters();
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    virtual angle::Result bindMetalRasterizationRateMap(gl::Context *,
+                                                        GLMTLRasterizationRateMapANGLE map);
+
   protected:
     const gl::State &mState;
     gl::MemoryProgramCache *mMemoryProgramCache;
diff --git a/src/libANGLE/renderer/gl/StateManagerGL.cpp b/src/libANGLE/renderer/gl/StateManagerGL.cpp
index f1da30007a..1589eceeec 100644
--- a/src/libANGLE/renderer/gl/StateManagerGL.cpp
+++ b/src/libANGLE/renderer/gl/StateManagerGL.cpp
@@ -2519,6 +2519,10 @@ angle::Result StateManagerGL::syncState(const gl::Context *context,
                             break;
                         case gl::state::EXTENDED_DIRTY_BIT_FETCH_PER_SAMPLE_ENABLED:
                             break;
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Nothing to do until ANGLE_variable_rasterization_rate_metal is
+                            // implemented.
+                            break;
                         default:
                             UNREACHABLE();
                             break;
diff --git a/src/libANGLE/renderer/metal/ContextMtl.h b/src/libANGLE/renderer/metal/ContextMtl.h
index 94a5d3f70d..479c07a037 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.h
+++ b/src/libANGLE/renderer/metal/ContextMtl.h
@@ -273,6 +273,9 @@ class ContextMtl : public ContextImpl, public mtl::Context
     angle::Result memoryBarrier(const gl::Context *context, GLbitfield barriers) override;
     angle::Result memoryBarrierByRegion(const gl::Context *context, GLbitfield barriers) override;
 
+    angle::Result bindMetalRasterizationRateMap(gl::Context *context,
+                                                GLMTLRasterizationRateMapANGLE map) override;
+
     // override mtl::ErrorHandler
     void handleError(GLenum error,
                      const char *message,
@@ -555,6 +558,7 @@ class ContextMtl : public ContextImpl, public mtl::Context
         DIRTY_BIT_RENDER_PIPELINE,
         DIRTY_BIT_UNIFORM_BUFFERS_BINDING,
         DIRTY_BIT_RASTERIZER_DISCARD,
+        DIRTY_BIT_VARIABLE_RASTERIZATION_RATE,
 
         DIRTY_BIT_INVALID,
         DIRTY_BIT_MAX = DIRTY_BIT_INVALID,
@@ -648,6 +652,8 @@ class ContextMtl : public ContextImpl, public mtl::Context
     IncompleteTextureSet mIncompleteTextures;
     ProvokingVertexHelper mProvokingVertexHelper;
 
+    mtl::RasterizationRateMapRef mRasterizationRateMap;
+
     mtl::ContextDevice mContextDevice;
 };
 
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index 93328924ff..07a5425f2c 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -250,6 +250,7 @@ void ContextMtl::onDestroy(const gl::Context *context)
     mIncompleteTextures.onDestroy(context);
     mProvokingVertexHelper.onDestroy(this);
     mDummyXFBRenderTexture = nullptr;
+    mRasterizationRateMap.reset();
 
     mContextDevice.reset();
 }
@@ -1398,6 +1399,9 @@ void ContextMtl::updateExtendedState(const gl::State &glState,
             case gl::state::EXTENDED_DIRTY_BIT_POLYGON_OFFSET_LINE_ENABLED:
                 mDirtyBits.set(DIRTY_BIT_DEPTH_BIAS);
                 break;
+            case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                mDirtyBits.set(DIRTY_BIT_VARIABLE_RASTERIZATION_RATE);
+                break;
             default:
                 break;
         }
@@ -1653,6 +1657,19 @@ angle::Result ContextMtl::memoryBarrierByRegion(const gl::Context *context, GLbi
     return angle::Result::Stop;
 }
 
+angle::Result ContextMtl::bindMetalRasterizationRateMap(gl::Context *context,
+                                                        GLMTLRasterizationRateMapANGLE map)
+{
+    id<MTLRasterizationRateMap> rateMap = (__bridge id<MTLRasterizationRateMap>)(map);
+    if (rateMap && rateMap.device != mContextDevice.get())
+    {
+        return angle::Result::Stop;
+    }
+
+    mRasterizationRateMap = std::move(rateMap);
+    return angle::Result::Continue;
+}
+
 // override mtl::ErrorHandler
 void ContextMtl::handleError(GLenum glErrorCode,
                              const char *message,
@@ -2074,7 +2091,11 @@ void ContextMtl::updateViewport(FramebufferMtl *framebufferMtl,
                                 float nearPlane,
                                 float farPlane)
 {
-    mViewport = mtl::GetViewport(viewport, framebufferMtl->getState().getDimensions().height,
+    int screenHeight = framebufferMtl->getState().getDimensions().height;
+    id<MTLRasterizationRateMap> rateMap = mRasterizationRateMap.get();
+    if (rateMap != nil)
+        screenHeight = (int)ceilf([rateMap mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(0, screenHeight) forLayer:0].y);
+    mViewport = mtl::GetViewport(viewport, screenHeight,
                                  framebufferMtl->flipY(), nearPlane, farPlane);
     mDirtyBits.set(DIRTY_BIT_VIEWPORT);
 
@@ -2604,7 +2625,7 @@ angle::Result ContextMtl::setupDrawImpl(const gl::Context *context,
                 mRenderEncoder.setViewport(mViewport);
                 break;
             case DIRTY_BIT_SCISSOR:
-                mRenderEncoder.setScissorRect(mScissorRect);
+                mRenderEncoder.setScissorRect(mScissorRect, mRasterizationRateMap);
                 break;
             case DIRTY_BIT_DRAW_FRAMEBUFFER:
                 // Already handled.
@@ -2629,6 +2650,13 @@ angle::Result ContextMtl::setupDrawImpl(const gl::Context *context,
             case DIRTY_BIT_RASTERIZER_DISCARD:
                 // Already handled.
                 break;
+            case DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                if (getState().privateState().isVariableRasterizationRateEnabled() &&
+                    mRasterizationRateMap)
+                {
+                    mRenderEncoder.setRasterizationRateMap(mRasterizationRateMap);
+                }
+                break;
             default:
                 UNREACHABLE();
                 break;
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.h b/src/libANGLE/renderer/metal/DisplayMtl.h
index c8b8ac3a69..f601b88620 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.h
+++ b/src/libANGLE/renderer/metal/DisplayMtl.h
@@ -140,6 +140,7 @@ class DisplayMtl : public DisplayImpl
     bool supportsDepth24Stencil8PixelFormat() const;
     bool supports32BitFloatFiltering() const;
     bool supportsBCTextureCompression() const;
+    bool supportsVariableRasterizationRate() const;
     bool isAMD() const;
     bool isAMDBronzeDriver() const;
     bool isAMDFireProDevice() const;
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index 2a9dea5d90..08c078e593 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -1145,6 +1145,10 @@ void DisplayMtl::initializeExtensions() const
     // qualifier on that hardware.
     mNativePLSOptions.supportsNoncoherent = !supportsAppleGPUFamily(1);
 
+    // GL_ANGLE_variable_rasterization_rate_metal
+    mNativeExtensions.variableRasterizationRateMetalANGLE =
+        mFeatures.hasVariableRasterizationRate.enabled;
+
     // "The GPUs in Apple3 through Apple8 families only support memory barriers for compute command
     // encoders, and for vertex-to-vertex and vertex-to-fragment stages of render command encoders."
     mHasFragmentMemoryBarriers = !supportsAppleGPUFamily(3);
@@ -1216,6 +1220,8 @@ void DisplayMtl::initializeFeatures()
     ANGLE_FEATURE_CONDITION((&mFeatures), hasExplicitMemBarrier, (isOSX || isCatalyst) && !isARM);
     ANGLE_FEATURE_CONDITION((&mFeatures), hasDepthAutoResolve, supportsEitherGPUFamily(3, 2));
     ANGLE_FEATURE_CONDITION((&mFeatures), hasStencilAutoResolve, supportsEitherGPUFamily(5, 2));
+    ANGLE_FEATURE_CONDITION((&mFeatures), hasVariableRasterizationRate,
+                            supportsVariableRasterizationRate());
     ANGLE_FEATURE_CONDITION((&mFeatures), allowMultisampleStoreAndResolve,
                             supportsEitherGPUFamily(3, 1));
 
@@ -1399,6 +1405,17 @@ bool DisplayMtl::supportsDepth24Stencil8PixelFormat() const
     return false;
 #endif
 }
+
+bool DisplayMtl::supportsVariableRasterizationRate() const
+{
+    if (@available(iOS 13.0, macOS 10.15.4, macCatalyst 13.4, tvOS 16.0, visionOS 1.0, *))
+    {
+        return [mMetalDevice supportsRasterizationRateMapWithLayerCount:1];
+    }
+
+    return false;
+}
+
 bool DisplayMtl::isAMD() const
 {
     return angle::IsAMD(mMetalDeviceVendorId);
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index ba7179e1e5..3556225e74 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -621,6 +621,8 @@ angle::Result FramebufferMtl::blitWithDraw(const gl::Context *context,
         ANGLE_TRY(ensureRenderPassStarted(context, &renderEncoder));
     }
 
+    renderEncoder->setRasterizationRateMap(nil);
+
     // Blit color
     if (blitColorBuffer)
     {
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.h b/src/libANGLE/renderer/metal/mtl_command_buffer.h
index 22cc8a5212..2e3c635d96 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.h
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.h
@@ -450,7 +450,8 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setStencilRefVal(uint32_t ref);
 
     RenderCommandEncoder &setViewport(const MTLViewport &viewport);
-    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect);
+    RenderCommandEncoder &setScissorRect(const MTLScissorRect &rect,
+                                         id<MTLRasterizationRateMap> map);
 
     RenderCommandEncoder &setBlendColor(float r, float g, float b, float a);
 
@@ -599,6 +600,8 @@ class RenderCommandEncoder final : public CommandEncoder
     RenderCommandEncoder &setDepthLoadAction(MTLLoadAction action, double clearValue);
     RenderCommandEncoder &setStencilLoadAction(MTLLoadAction action, uint32_t clearValue);
 
+    RenderCommandEncoder &setRasterizationRateMap(id<MTLRasterizationRateMap> map);
+
     void setLabel(NSString *label);
 
     void pushDebugGroup(NSString *label) override;
diff --git a/src/libANGLE/renderer/metal/mtl_command_buffer.mm b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
index 31448a4638..57c40de616 100644
--- a/src/libANGLE/renderer/metal/mtl_command_buffer.mm
+++ b/src/libANGLE/renderer/metal/mtl_command_buffer.mm
@@ -1881,12 +1881,20 @@ RenderCommandEncoder &RenderCommandEncoder::setViewport(const MTLViewport &viewp
     return *this;
 }
 
-RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect)
+RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect &rect,
+                                                           id<MTLRasterizationRateMap> map)
 {
+    auto maxScissorRect =
+        MTLCoordinate2DMake(mRenderPassMaxScissorRect.width, mRenderPassMaxScissorRect.height);
+    if (map)
+    {
+        maxScissorRect = [map mapPhysicalToScreenCoordinates:maxScissorRect forLayer:0];
+    }
+
     NSUInteger clampedWidth =
-        rect.x > mRenderPassMaxScissorRect.width ? 0 : mRenderPassMaxScissorRect.width - rect.x;
+        rect.x > maxScissorRect.x ? 0 : (NSUInteger)ceilf(maxScissorRect.x) - rect.x;
     NSUInteger clampedHeight =
-        rect.y > mRenderPassMaxScissorRect.height ? 0 : mRenderPassMaxScissorRect.height - rect.y;
+        rect.y > maxScissorRect.y ? 0 : (NSUInteger)ceilf(maxScissorRect.y) - rect.y;
 
     MTLScissorRect clampedRect = {rect.x, rect.y, std::min(rect.width, clampedWidth),
                                   std::min(rect.height, clampedHeight)};
@@ -1898,6 +1906,22 @@ RenderCommandEncoder &RenderCommandEncoder::setScissorRect(const MTLScissorRect
 
     mStateCache.scissorRect = clampedRect;
 
+    if (map)
+    {
+        auto adjustedOrigin =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.x, clampedRect.y)
+                                       forLayer:0];
+        auto adjustedSize =
+            [map mapPhysicalToScreenCoordinates:MTLCoordinate2DMake(clampedRect.width,
+                                                                    clampedRect.height)
+                                       forLayer:0];
+
+        clampedRect.x      = (NSUInteger)floorf(adjustedOrigin.x);
+        clampedRect.y      = (NSUInteger)floorf(adjustedOrigin.y);
+        clampedRect.width  = (NSUInteger)ceilf(adjustedSize.x);
+        clampedRect.height = (NSUInteger)ceilf(adjustedSize.y);
+    }
+
     mCommands.push(CmdType::SetScissorRect).push(clampedRect);
 
     return *this;
@@ -2398,6 +2422,15 @@ RenderCommandEncoder &RenderCommandEncoder::setStencilLoadAction(MTLLoadAction a
     return *this;
 }
 
+RenderCommandEncoder &RenderCommandEncoder::setRasterizationRateMap(id<MTLRasterizationRateMap> map)
+{
+    if (mCachedRenderPassDescObjC.get().rasterizationRateMap != map)
+    {
+        mCachedRenderPassDescObjC.get().rasterizationRateMap = map;
+    }
+    return *this;
+}
+
 void RenderCommandEncoder::setLabel(NSString *label)
 {
     mLabel = std::move(label);
diff --git a/src/libANGLE/renderer/metal/mtl_common.h b/src/libANGLE/renderer/metal/mtl_common.h
index 6d9ad791ac..8206301c2c 100644
--- a/src/libANGLE/renderer/metal/mtl_common.h
+++ b/src/libANGLE/renderer/metal/mtl_common.h
@@ -265,6 +265,8 @@ class WrappedObject
     T mMetalObject = nil;
 };
 
+using RasterizationRateMapRef = angle::ObjCPtr<id<MTLRasterizationRateMap>>;
+
 // The native image index used by Metal back-end,  the image index uses native mipmap level instead
 // of "virtual" level modified by OpenGL's base level.
 using MipmapNativeLevel = gl::LevelIndexWrapper<uint32_t>;
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index c11203e2a3..61c72efeb5 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -640,8 +640,10 @@ void SetupCommonBlitWithDrawStates(const gl::Context *context,
         GetViewport(params.dstRect, params.dstTextureSize.height, params.dstFlipY);
     MTLScissorRect scissorRectMtl =
         GetScissorRect(params.dstScissorRect, params.dstTextureSize.height, params.dstFlipY);
+    // TODO(djg): Should the rasterization rate map affect blit operations?
+    // Would this require changes to the shader to apply transformation
     cmdEncoder->setViewport(viewportMtl);
-    cmdEncoder->setScissorRect(scissorRectMtl);
+    cmdEncoder->setScissorRect(scissorRectMtl, nil);
 
     if (params.src)
     {
@@ -1119,7 +1121,7 @@ angle::Result ClearUtils::setupClearWithDraw(const gl::Context *context,
     scissorRect = GetScissorRect(params.clearArea, params.dstTextureSize.height, params.flipY);
 
     cmdEncoder->setViewport(viewport);
-    cmdEncoder->setScissorRect(scissorRect);
+    cmdEncoder->setScissorRect(scissorRect, nil);
 
     // uniform
     ClearParamsUniform uniformParams;
@@ -2487,7 +2489,7 @@ angle::Result CopyPixelsUtils::unpackPixelsWithDraw(const gl::Context *context,
     scissorRect = GetScissorRect(rect);
 
     cmdEncoder->setViewport(viewport);
-    cmdEncoder->setScissorRect(scissorRect);
+    cmdEncoder->setScissorRect(scissorRect, nil);
 
     // uniform
     CopyPixelFromBufferUniforms options;
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000000..23e8295bcc
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,65 @@
+#!/usr/bin/python3
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=os.path.basename(sys.argv[0]), copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file))
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+
+    append_file_as_byte_array_string('gDefaultMetallib', input_file, output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/vulkan/ContextVk.cpp b/src/libANGLE/renderer/vulkan/ContextVk.cpp
index e32c9ded9f..4408283b8b 100644
--- a/src/libANGLE/renderer/vulkan/ContextVk.cpp
+++ b/src/libANGLE/renderer/vulkan/ContextVk.cpp
@@ -5867,6 +5867,10 @@ angle::Result ContextVk::syncState(const gl::Context *context,
                             break;
                         case gl::state::EXTENDED_DIRTY_BIT_BLEND_ADVANCED_COHERENT:
                             break;
+                        case gl::state::EXTENDED_DIRTY_BIT_VARIABLE_RASTERIZATION_RATE:
+                            // Nothing to do until ANGLE_variable_rasterization_rate_metal is
+                            // implemented.
+                            break;
                         default:
                             UNREACHABLE();
                     }
diff --git a/src/libANGLE/validationES2.cpp b/src/libANGLE/validationES2.cpp
index 2b6a85e24e..2e88abd3b8 100644
--- a/src/libANGLE/validationES2.cpp
+++ b/src/libANGLE/validationES2.cpp
@@ -715,6 +715,10 @@ bool ValidCapUncommon(const PrivateState &state, ErrorSet *errors, GLenum cap, b
         case GL_BLEND_ADVANCED_COHERENT_KHR:
             return state.getExtensions().blendEquationAdvancedCoherentKHR;
 
+        // GL_ANGLE_variable_rasterization_rate_metal
+        case GL_VARIABLE_RASTERIZATION_RATE_ANGLE:
+            return state.getExtensions().variableRasterizationRateMetalANGLE;
+
         default:
             break;
     }
@@ -5916,6 +5920,18 @@ bool ValidateMaxShaderCompilerThreadsKHR(const Context *context,
     return true;
 }
 
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLMTLRasterizationRateMapANGLE map)
+{
+    if (!context->getExtensions().variableRasterizationRateMetalANGLE)
+    {
+        ANGLE_VALIDATION_ERROR(GL_INVALID_OPERATION, kExtensionNotEnabled);
+        return false;
+    }
+    return true;
+}
+
 bool ValidateMultiDrawArraysANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
                                   PrimitiveMode mode,
diff --git a/src/libANGLE/validationES32.cpp b/src/libANGLE/validationES32.cpp
index 6f3b45455e..5717b5e2b1 100644
--- a/src/libANGLE/validationES32.cpp
+++ b/src/libANGLE/validationES32.cpp
@@ -436,6 +436,10 @@ bool ValidateGetPointerv(const Context *context,
             }
             break;
 
+        // GL_ANGLE_variable_rasterization_rate_metal
+        case GL_METAL_RASTERIZATION_RATE_MAP_BINDING_ANGLE:
+            return context->getExtensions().variableRasterizationRateMetalANGLE;
+
         default:
             ANGLE_VALIDATION_ERROR(GL_INVALID_ENUM, kInvalidPointerQuery);
             return false;
diff --git a/src/libANGLE/validationESEXT_autogen.h b/src/libANGLE/validationESEXT_autogen.h
index 875f1e5402..b17ff99825 100644
--- a/src/libANGLE/validationESEXT_autogen.h
+++ b/src/libANGLE/validationESEXT_autogen.h
@@ -894,6 +894,11 @@ bool ValidateGetTranslatedShaderSourceANGLE(const Context *context,
                                             const GLsizei *length,
                                             const GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+bool ValidateBindMetalRasterizationRateMapANGLE(const Context *context,
+                                                angle::EntryPoint entryPoint,
+                                                GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 bool ValidateAcquireTexturesANGLE(const Context *context,
                                   angle::EntryPoint entryPoint,
diff --git a/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp b/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
index c2a6220ae8..061bbc5844 100644
--- a/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
+++ b/src/libGLESv2/egl_stubs_getprocaddress_autogen.cpp
@@ -181,6 +181,7 @@ const ProcEntry g_procTable[] = {
     {"glBindFramebuffer", P(GL_BindFramebuffer)},
     {"glBindFramebufferOES", P(GL_BindFramebufferOES)},
     {"glBindImageTexture", P(GL_BindImageTexture)},
+    {"glBindMetalRasterizationRateMapANGLE", P(GL_BindMetalRasterizationRateMapANGLE)},
     {"glBindProgramPipeline", P(GL_BindProgramPipeline)},
     {"glBindProgramPipelineEXT", P(GL_BindProgramPipelineEXT)},
     {"glBindRenderbuffer", P(GL_BindRenderbuffer)},
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.cpp b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
index 6b419904d2..c80fa826eb 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.cpp
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.cpp
@@ -6338,6 +6338,34 @@ void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
     ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY GL_BindMetalRasterizationRateMapANGLE(GLMTLRasterizationRateMapANGLE map)
+{
+    Context *context = GetValidGlobalContext();
+    EVENT(context, GLBindMetalRasterizationRateMapANGLE, "context = %d, map = 0x%016" PRIxPTR "",
+          CID(context), (uintptr_t)map);
+
+    if (context)
+    {
+        SCOPED_SHARE_CONTEXT_LOCK(context);
+        bool isCallValid =
+            (context->skipValidation() ||
+             ValidateBindMetalRasterizationRateMapANGLE(
+                  context, angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE, map));
+        if (isCallValid)
+        {
+            context->bindMetalRasterizationRateMap(map);
+        }
+        ANGLE_CAPTURE_GL(BindMetalRasterizationRateMapANGLE, isCallValid, context, map);
+    }
+    else
+    {
+        GenerateContextLostErrorOnCurrentGlobalContext(
+            angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE);
+    }
+    ASSERT(!egl::Display::GetCurrentThreadUnlockedTailCall()->any());
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                          const GLuint *textures,
diff --git a/src/libGLESv2/entry_points_gles_ext_autogen.h b/src/libGLESv2/entry_points_gles_ext_autogen.h
index 8c6e0109e8..53b92a6b06 100644
--- a/src/libGLESv2/entry_points_gles_ext_autogen.h
+++ b/src/libGLESv2/entry_points_gles_ext_autogen.h
@@ -662,6 +662,10 @@ ANGLE_EXPORT void GL_APIENTRY GL_GetTranslatedShaderSourceANGLE(GLuint shader,
                                                                 GLsizei *length,
                                                                 GLchar *source);
 
+// GL_ANGLE_variable_rasterization_rate_metal
+ANGLE_EXPORT void GL_APIENTRY
+GL_BindMetalRasterizationRateMapANGLE(GLMTLRasterizationRateMapANGLE map);
+
 // GL_ANGLE_vulkan_image
 ANGLE_EXPORT void GL_APIENTRY GL_AcquireTexturesANGLE(GLuint numTextures,
                                                       const GLuint *textures,
diff --git a/src/libGLESv2/libGLESv2_autogen.cpp b/src/libGLESv2/libGLESv2_autogen.cpp
index 39da5605f0..456e83aeca 100644
--- a/src/libGLESv2/libGLESv2_autogen.cpp
+++ b/src/libGLESv2/libGLESv2_autogen.cpp
@@ -3801,6 +3801,12 @@ void GL_APIENTRY glGetTranslatedShaderSourceANGLE(GLuint shader,
     return GL_GetTranslatedShaderSourceANGLE(shader, bufSize, length, source);
 }
 
+// GL_ANGLE_variable_rasterization_rate_metal
+void GL_APIENTRY glBindMetalRasterizationRateMapANGLE(GLMTLRasterizationRateMapANGLE map)
+{
+    return GL_BindMetalRasterizationRateMapANGLE(map);
+}
+
 // GL_ANGLE_vulkan_image
 void GL_APIENTRY glAcquireTexturesANGLE(GLuint numTextures,
                                         const GLuint *textures,
diff --git a/src/libGLESv2/libGLESv2_autogen.def b/src/libGLESv2/libGLESv2_autogen.def
index f6af5fb024..256cdd03cf 100644
--- a/src/libGLESv2/libGLESv2_autogen.def
+++ b/src/libGLESv2/libGLESv2_autogen.def
@@ -656,6 +656,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
diff --git a/src/libGLESv2/libGLESv2_no_capture_autogen.def b/src/libGLESv2/libGLESv2_no_capture_autogen.def
index d8577a00c2..766075201f 100644
--- a/src/libGLESv2/libGLESv2_no_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_no_capture_autogen.def
@@ -656,6 +656,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
diff --git a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
index 4d5d40643a..ac668febf6 100644
--- a/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
+++ b/src/libGLESv2/libGLESv2_vulkan_secondaries_autogen.def
@@ -656,6 +656,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
diff --git a/src/libGLESv2/libGLESv2_with_capture_autogen.def b/src/libGLESv2/libGLESv2_with_capture_autogen.def
index 1c78ab3ff3..ccf4e5baa5 100644
--- a/src/libGLESv2/libGLESv2_with_capture_autogen.def
+++ b/src/libGLESv2/libGLESv2_with_capture_autogen.def
@@ -656,6 +656,9 @@ EXPORTS
     ; GL_ANGLE_translated_shader_source
     glGetTranslatedShaderSourceANGLE
 
+    ; GL_ANGLE_variable_rasterization_rate_metal
+    glBindMetalRasterizationRateMapANGLE
+
     ; GL_ANGLE_vulkan_image
     glAcquireTexturesANGLE
     glReleaseTexturesANGLE
diff --git a/util/autogen/angle_features_autogen.cpp b/util/autogen/angle_features_autogen.cpp
index e8162b9d1e..aeb0190621 100644
--- a/util/autogen/angle_features_autogen.cpp
+++ b/util/autogen/angle_features_autogen.cpp
@@ -222,6 +222,7 @@ constexpr PackedEnumMap<Feature, const char *> kFeatureNames = {{
     {Feature::HasShaderStencilOutput, "hasShaderStencilOutput"},
     {Feature::HasStencilAutoResolve, "hasStencilAutoResolve"},
     {Feature::HasTextureSwizzle, "hasTextureSwizzle"},
+    {Feature::HasVariableRasterizationRate, "hasVariableRasterizationRate"},
     {Feature::InitFragmentOutputVariables, "initFragmentOutputVariables"},
     {Feature::InitializeCurrentVertexAttributes, "initializeCurrentVertexAttributes"},
     {Feature::InjectAsmStatementIntoLoopBodies, "injectAsmStatementIntoLoopBodies"},
diff --git a/util/autogen/angle_features_autogen.h b/util/autogen/angle_features_autogen.h
index 27363be2d5..e899fe1b71 100644
--- a/util/autogen/angle_features_autogen.h
+++ b/util/autogen/angle_features_autogen.h
@@ -222,6 +222,7 @@ enum class Feature
     HasShaderStencilOutput,
     HasStencilAutoResolve,
     HasTextureSwizzle,
+    HasVariableRasterizationRate,
     InitFragmentOutputVariables,
     InitializeCurrentVertexAttributes,
     InjectAsmStatementIntoLoopBodies,
diff --git a/util/capture/frame_capture_replay_autogen.cpp b/util/capture/frame_capture_replay_autogen.cpp
index 2bcb54eba8..9453c1e791 100644
--- a/util/capture/frame_capture_replay_autogen.cpp
+++ b/util/capture/frame_capture_replay_autogen.cpp
@@ -105,6 +105,10 @@ void ReplayTraceFunctionCall(const CallCapture &call, const TraceFunctionMap &cu
                                captures[3].value.GLbooleanVal, captures[4].value.GLintVal,
                                captures[5].value.GLenumVal, captures[6].value.GLenumVal);
             break;
+        case angle::EntryPoint::GLBindMetalRasterizationRateMapANGLE:
+            glBindMetalRasterizationRateMapANGLE(
+                captures[0].value.GLMTLRasterizationRateMapANGLEVal);
+            break;
         case angle::EntryPoint::GLBindProgramPipeline:
             glBindProgramPipeline(gProgramPipelineMap[captures[0].value.GLuintVal]);
             break;
diff --git a/util/capture/trace_gles_loader_autogen.cpp b/util/capture/trace_gles_loader_autogen.cpp
index 380d1f5786..3f887acffc 100644
--- a/util/capture/trace_gles_loader_autogen.cpp
+++ b/util/capture/trace_gles_loader_autogen.cpp
@@ -608,6 +608,8 @@ ANGLE_TRACE_LOADER_EXPORT PFNGLSAMPLEMASKIANGLEPROC t_glSampleMaskiANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC t_glBindUniformLocationCHROMIUM;
@@ -1796,6 +1798,9 @@ void LoadTraceGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     t_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    t_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     t_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     t_glReleaseTexturesANGLE =
diff --git a/util/capture/trace_gles_loader_autogen.h b/util/capture/trace_gles_loader_autogen.h
index b7ea614a0d..773692b721 100644
--- a/util/capture/trace_gles_loader_autogen.h
+++ b/util/capture/trace_gles_loader_autogen.h
@@ -581,6 +581,7 @@
 #define glSampleMaskiANGLE t_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE t_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE t_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE t_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE t_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE t_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM t_glBindUniformLocationCHROMIUM
@@ -1484,6 +1485,8 @@ ANGLE_TRACE_LOADER_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC
     t_glTexStorage2DMultisampleANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC
     t_glGetTranslatedShaderSourceANGLE;
+ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    t_glBindMetalRasterizationRateMapANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC t_glAcquireTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC t_glReleaseTexturesANGLE;
 ANGLE_TRACE_LOADER_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC
diff --git a/util/capture/trace_interpreter_autogen.cpp b/util/capture/trace_interpreter_autogen.cpp
index 640af6a6ac..4aa01988d0 100644
--- a/util/capture/trace_interpreter_autogen.cpp
+++ b/util/capture/trace_interpreter_autogen.cpp
@@ -910,6 +910,13 @@ CallCapture ParseCallCapture(const Token &nameToken,
             paramTokens, strings);
         return CallCapture(EntryPoint::GLBindImageTexture, std::move(params));
     }
+    if (strcmp(nameToken, "glBindMetalRasterizationRateMapANGLE") == 0)
+    {
+        ParamBuffer params =
+            ParseParameters<std::remove_pointer<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>::type>(
+                paramTokens, strings);
+        return CallCapture(EntryPoint::GLBindMetalRasterizationRateMapANGLE, std::move(params));
+    }
     if (strcmp(nameToken, "glBindProgramPipeline") == 0)
     {
         ParamBuffer params =
diff --git a/util/gles_loader_autogen.cpp b/util/gles_loader_autogen.cpp
index d7502418a7..d6963da66b 100644
--- a/util/gles_loader_autogen.cpp
+++ b/util/gles_loader_autogen.cpp
@@ -591,6 +591,8 @@ ANGLE_UTIL_EXPORT PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGLE;
 ANGLE_UTIL_EXPORT PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
@@ -1770,6 +1772,9 @@ void LoadUtilGLES(LoadProc loadProc)
         loadProc("glTexStorage2DMultisampleANGLE"));
     l_glGetTranslatedShaderSourceANGLE = reinterpret_cast<PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC>(
         loadProc("glGetTranslatedShaderSourceANGLE"));
+    l_glBindMetalRasterizationRateMapANGLE =
+        reinterpret_cast<PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC>(
+            loadProc("glBindMetalRasterizationRateMapANGLE"));
     l_glAcquireTexturesANGLE =
         reinterpret_cast<PFNGLACQUIRETEXTURESANGLEPROC>(loadProc("glAcquireTexturesANGLE"));
     l_glReleaseTexturesANGLE =
diff --git a/util/gles_loader_autogen.h b/util/gles_loader_autogen.h
index 7ca76ff153..0621a22247 100644
--- a/util/gles_loader_autogen.h
+++ b/util/gles_loader_autogen.h
@@ -581,6 +581,7 @@
 #define glSampleMaskiANGLE l_glSampleMaskiANGLE
 #define glTexStorage2DMultisampleANGLE l_glTexStorage2DMultisampleANGLE
 #define glGetTranslatedShaderSourceANGLE l_glGetTranslatedShaderSourceANGLE
+#define glBindMetalRasterizationRateMapANGLE l_glBindMetalRasterizationRateMapANGLE
 #define glAcquireTexturesANGLE l_glAcquireTexturesANGLE
 #define glReleaseTexturesANGLE l_glReleaseTexturesANGLE
 #define glBindUniformLocationCHROMIUM l_glBindUniformLocationCHROMIUM
@@ -1453,6 +1454,8 @@ ANGLE_UTIL_EXPORT extern PFNGLGETMULTISAMPLEFVANGLEPROC l_glGetMultisamplefvANGL
 ANGLE_UTIL_EXPORT extern PFNGLSAMPLEMASKIANGLEPROC l_glSampleMaskiANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLTEXSTORAGE2DMULTISAMPLEANGLEPROC l_glTexStorage2DMultisampleANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC l_glGetTranslatedShaderSourceANGLE;
+ANGLE_UTIL_EXPORT extern PFNGLBINDMETALRASTERIZATIONRATEMAPANGLEPROC
+    l_glBindMetalRasterizationRateMapANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLACQUIRETEXTURESANGLEPROC l_glAcquireTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLRELEASETEXTURESANGLEPROC l_glReleaseTexturesANGLE;
 ANGLE_UTIL_EXPORT extern PFNGLBINDUNIFORMLOCATIONCHROMIUMPROC l_glBindUniformLocationCHROMIUM;
